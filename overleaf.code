\documentclass{article}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english, main=bulgarian]{babel}

\usepackage[letterpaper,top=2cm,bottom=2cm,left=3.1cm,right=3.1cm,marginparwidth=1.75cm]{geometry}
\usepackage[fontsize=12pt]{fontsize}

\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{graphicx}

\usepackage{biblatex}
\addbibresource{bib.bib} 

\usepackage{algorithm2e}
\SetAlFnt{\small}

\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{hyphenat}
\pagenumbering{arabic}
\usepackage{titlesec}
\usepackage{textcomp}
\usepackage{pgfplots}
\usepackage{tikz}
\usepackage{float}
\usepackage{setspace}
\usepackage{indentfirst}
\usepackage{subfig}

\pgfplotsset{width=10cm,compat=1.9}

\newtheoremstyle{myplain}
  {\topsep}
  {\topsep}
  {\itshape\onehalfspacing}
  {0pt}
  {\bfseries}
  {.}
  {5pt}
  {}   
\newtheoremstyle{myplainproof}
  {\topsep}
  {\topsep}
  {\itshape\onehalfspacing}
  {0pt}
  {\bfseries}
  {:}
  {5pt}
  {}     
\theoremstyle{myplain}
\newtheorem{definition}{Дефиниция}
\theoremstyle{myplain}
\newtheorem{theorem}{Теорема}[definition]
\theoremstyle{myplainproof}
\newtheorem*{myproof}{Доказателство}

\titleformat*{\section}{\large\bfseries}
\titleformat*{\subsection}{\large\bfseries}
\titleformat*{\subsubsection}{\large\bfseries}
\titleformat*{\paragraph}{\large\bfseries}
\titleformat*{\subparagraph}{\large\bfseries}

\title{Генерален и кеш-безразличен метод за отговаряне на заявки за интервали използващ запълващата пространството крива на Хилберт}

\setlength{\parindent}{4em}
\setlength{\parskip}{0.5em}
\linespread{1.25}

\begin{document}

\linespread{0.5}
\begin{center}
\includegraphics[width=\textwidth]{u4imi.jpg}
\end{center}
\vspace{1.5cm}
\begin{center}
\huge{\textbf{ДВАДЕСЕТ И ВТОРА УЧЕНИЧЕСКА КОНФЕРЕНЦИЯ\\ УК’22}}
\end{center}
\vspace{1.5cm}
\begin{center}
\huge{\textbf{
Хилбертообразни, запълващи-пространството криви в задачи за заявки в интервали}}
\end{center}
\vspace{0.5cm}
\begin{center}
\Large{
Атанас Димитров Димитров\\
СМГ „Паисий Хилендарски“, град София
}
\end{center}
\vspace{1cm}
\begin{center}
\Large{
Научен ръководител:\\
Радослав Стоянов Димитров\\
Oxford
}
\end{center}
\clearpage
\linespread{1.25}

\begin{abstract}
Статията е от областта на дизайн и анализ на алгоритми. В нея са представени и сравнени различни методи за отговаряне на заявки за интервали в предварително зададено множество от данни. Разгледана е връзката между задачата и намирането на минимален по дължнина хамилтонов път в многоизмерна решетка и са приложени Хилбертообразни криви като добри практически приближения.
\end{abstract}

\begin{otherlanguage}{english}
\begin{abstract}
The following paper is in the area of design and analysis of algorithms. Its purpose is to survey and compare different methods for answering range queries in a given set of data. The relation between minimum length hamiltonian paths in multidimentional grids and the given problem is examined and Hilbertian curves are presented as a good practical approximation. 
\end{abstract}
\end{otherlanguage}
\clearpage

\tableofcontents
\clearpage

\section{Въведение}
\subsection{Дефиниция на задачата}

В статията са разгледани алгоритми, които отговарят на въпроси, свързани с предварително зададен масив от данни. Формално казано, имаме зададен масив с размер $N$ и със стойности $a_i$  за $\forall$  $0 \le i < N$. Освен това имаме последователност от заявки и обновления. С $U$ ще означим нареденото множеството от обновления, всяко характеризирано от $(ind, val)$ - променяме стойността на масива на позиция $ind$ на $val$. С $Q$ ще означим нареденото множество от заявки, всяка от които ще означим с тройката $(l, r, u)$ - тя търси отговор на някакъв въпрос за интервала $l\le i \le r$, като се имат предвид първите $u$ обновления. Друго валидно означение на елементите на заявките е $l_i, r_i, u_i$ за $0\le i < |Q|$, а за обновленията ще въведем означенията $ind_i, val_i$ и $old_i$ (това е стойността на позиция $ind_i$ преди обновлението) за $0\le i < |U|$. 

\subsection{Значението на ефикасните алгоритми за отговаряне на заявки}
В света около нас често се налага разглеждането на големи количества от данни. Така се стига до заключението, че за пълноценно използване на технологиите са наложителни ефикасни алгоритми за справянето с динамични промени и въпроси в данните.
\par 
Друго полезно приложение на алгоритмите, отговарящи на завки, е като помощни при различни задачи свързани например с динамичното програмиране или алчните алгоритми.

\subsection{Използване на черна кутия}
Черната кутия е структура от данни, която отговаря на множество, в което със сложност О(Т) могат да се добавят елементи, да се изваждат елементи и да се намира отговор на даден въпрос за множеството (максимум; сума; минимум; най-малко число, което не се среща в него; най-често срещаното число в него). Това е начин да се направи абстрактен въпроса в дадена задача, за да може да се изложи генерален метод. В статията, която следва, е разгледан въпросът на такава, за която всички от гореизброените операции са с една и съща сложност - О(Т). 


\subsection{Познати алгоритми}
\subsubsection{Наивен алгоритъм}

Наивният алгоритъм се състои в отговаряне на всяка заявка, сортирайки ги от такава с най-малко $u$, минавайки по всички елементи $a_i$ в интервала $(l, r)$ и слагайки ги в черната кутия. При обновления на елементи в масива единственото, което трябва да се направи, е да се промени стойността в паметта. При анализ сложността на алгоритъма е $O(\sum_{i=0}^{|Q|-1} (r_i-l_i)*T+|U|)$. Тъй като всяка заявка може да е $(1, n)$, следва, че финалната сложност е  $O(N*|Q|*T+|U|)$.

\subsubsection{Специализиран алгоритъм за някои задачи}
Нека разгледаме въпроси, които означаваме с функцията $f:\mathbb{R}^{m+1}\rightarrow \mathbb{R}$, за която е вярно, че $f(S_1 \cup S_2) = f(\{f(S_1), f(S_2)\})$. В такива случаи можем да използваме сегментно дърво \cite{segment-tree}. В тях сложността е по-добра от тази на наивния алгоритъм - $O(logN)$ на заявка и $O(N)$ за предварително построяване на дървото, следователно общата сложност е $O(|Q|*logN+|U|*logN+N)$. 

\subsubsection{Разделяне на ленти}
Разделянето на ленти е алгоритъм, възползващ се от съществуването на черна кутия. Той подрежда заявките в няколко групи в зависимост от стойностите им на $l$ и $u$. По-кокретно, той избира константа $BLOCK$, след това групира в "ленти" всички заявки $a, b$, за които $\lfloor {\frac{l_a}{BLOCK}} \rfloor = \lfloor {\frac{l_b}{BLOCK}} \rfloor$ и $\lfloor {\frac{u_a}{BLOCK}} \rfloor = \lfloor {\frac{u_b}{BLOCK}} \rfloor$. Отговарянето на заявките във всяка "лента" се случва по ред на нарастващо $r$, използвайки алгоритъм, подобен на \ref{move:dynamic}, за придвижването между 2 последователни заявки. Сложността може да бъде изчислена като $O(d*|Q|^{\frac{d-1}{d}}*N)$, ако бъде избрана добра стойност на константата $BLOCK$.


\section{Релация на проблема с този за минимален по дължина хамилтонов път}
\label{hamilton}
\subsection{Заявки в статичен масив}
\label{quer:stat}
Нека се спрем на случая, в който $|U|=0$, т.е. няма обновления. След това при разглеждане на процедурата, предложена в 1.4.1, можем да направим следната оптимизация - вместо всеки път да започваме да пълним структурата от данни наново, ще подредим заявките по произволен ред и ще опишем начин, по който ако вече структурата съдържа елементите отговарящи на интервала $(l_i, r_i)$, можем да преминем в състояние, такова че структурата да съдържа елементите в интервала $(l_{i+1}, r_{i+1})$. В псевдoкод \ref{move:static} е показан код, отговарящ на описаната задача. Сложността можем да изчислим като $O(\sum_{i=2}^{N}(|l_i - l_{i-1}| + |r_i - r_{i-1}|))$. Тъй като може да се получи ситуация, в която се редуват заявки $(1, N)$, $(N/2, N/2)$, то сложността отново е от порядък $O(|Q|*N*T)$.
\par
Нека разгледаме претеглен граф $G=(V, E)$, където $|V|=N$, а в $E$ има ребро $ab$ с дължина $c$ между всяко $0<a,b<|Q|$, където $c=|l_a - l_b| + |r_a - r_b|$. Така трансформираме задачата по подреждане в такава за минимален по дължина манхатанов хамилтонов път. Понеже този проблем е известен като NP-сложен, можем единствено да мислим в посока евристики за апроксимации \cite{mo}.

\renewcommand{\baselinestretch}{0.25}
\RestyleAlgo{ruled}
\SetKwComment{Comment}{/* }{ */}
\begin{algorithm}[H]
\caption{Преместване на $(l, r)$ в $(l', r')$}\label{alg:two}
\KwData{$T$ черната кутия}
\KwData{$(l, r)$ интервал, съдържанието на който е във $T$}
\KwData{$(l', r')$ интервал, чието съдържание ще бъде в $T$ след изпълнението на алгоритъма}
\KwResult{$T$ съдържащо елементите на $(l', r')$}
$pl \gets l$\;
$pr \gets r$\;
\While{pl < l'} {
    \tcp*[h]{Изважда всички елементи в интервала $l\le i<l'$}\\
    remove($T$, $a_{pl}$)\;
    $pl \gets pl + 1$\;
}
\While{pl > l'} {
    \tcp*[h]{Добавя всички елементи в интервала $l'\le i<l$}\\
    $pl \gets pl - 1$\;
    add($T$, $a_{pl}$)\;
}
\While{pr < r'} {
    \tcp*[h]{Добавя всички елементи в интервала $r<i\le r'$}\\
    $pr \gets pr + 1$\;
    add($T$, $a_{pr}$)\;
}
\While{pr > r'} {
    \tcp*[h]{Изважда всички елементи в интервала $r'<i\le r$}\\
    remove($T$, $a_{pr}$)\;
    $pr \gets pr - 1$\;
}
\label{move:static}
\end{algorithm}
\renewcommand{\baselinestretch}{1.50}

\subsection{Заявки в променящ се масив}
Псевдокод \ref{move:dynamic} обяснява метод, с който може да се разшири решението в случай че $|Q| \ne 0$. По аналог на доказателството в секция \ref{quer:stat}, тук ще търсим минимален манхатанов хамилтонов път, но между точките в $\mathbb{N}^{3}$.


\renewcommand{\baselinestretch}{1}
\RestyleAlgo{ruled}
\SetKwComment{Comment}{/* }{ */}
\begin{algorithm}[H]
\caption{Преместване на $(l, r, u)$ в $(l', r', u')$}
\KwData{$T$ черната кутия}
\KwData{$(l, r, u)$ интервал, съдържанието на който е във $T$}
\KwData{$(l', r', u')$ интервал, чието съдържание ще бъде в $T$ след изпълнението на алгоритъма}
\KwResult{$T$ съдържащо елементите на $(l', r', u')$}
$pl \gets l$\;
$pr \gets r$\;
\While{pl < l'} {
    \tcp*[h]{Изважда всички елементи в интервала $l\le i<l'$}\\
    remove($T$, $a_{pl}$)\;
    $pl \gets pl + 1$\;
}
\While{pl > l'} {
    \tcp*[h]{Добавя всички елементи в интервала $l'\le i<l$}\\
    $pl \gets pl - 1$\;
    add($T$, $a_{pl}$)\;
}
\While{pr < r'} {
    \tcp*[h]{Добавя всички елементи в интервала $r<i\le r'$}\\
    $pr \gets pr + 1$\;
    add($T$, $a_{pr}$)\;
}
\While{pr > r'} {
    \tcp*[h]{Изважда всички елементи в интервала $r'<i\le r$}\\
    remove($T$, $a_{pr}$)\;
    $pr \gets pr - 1$\;
}
\While{pu < u'} {
    \tcp*[h]{Прилага всички обновления в интервала $u<i\le u'$}\\    
    \If{$l \le ind_{pu} \le r$} {
        remove($T$, $a_{ind_{pu}}$)\;
        add($T$, $val_{pu}$)\;
    }
    $a_{ind_{pu}} \gets val_{pu}$\;
    $pu \gets pu + 1$
}
\While{pu > u'} {
    \tcp*[h]{Връща всички обновления в интервала $u'<i\le u$}\\      
    \If{$l \le ind_{pu} \le r$} {
        remove($T$, $a_{ind_{pu}}$)\;
        add($T$, $old_{pu}$)\;
    }
    $a_{ind_{pu}} \gets old_{pu}$\;
    $pu \gets pu - 1$
}
\label{move:dynamic}
\end{algorithm}
\renewcommand{\baselinestretch}{1.50}

\section{Използване на запълващи-пространството криви}
Тъй като по определение запълващи-пространството криви минават през всички клетки на $N\times N$ решетка, то може да подредим всички заявки по реда, по който кривата ги обхожда. 
\par
Забележка: Аналогични разсъждения могат да се приложат и в по-високите измерения. 

\subsection{Крива на Xилберт}
\subsubsection{Конструкция}
Кривата на Хилберт е крива минаваща през всички клетки на таблица $N \times N$ за $N=2^k$. Тя е създадена от 4 криви на Хилберт за таблици $N' \times N'$ за $N'=2^{k-1}$, като са направени завъртания на 2 от тях съответно по часовниковата и обратно на часовниковата стрелка. На фигура \ref{constr:hil} е показан процесът на долепяне на четири $4 \times 4$ таблици в една $16 \times 16$. В статията се разглежда реда, по който клетките биват обходени от кривата. На фигура \ref{numb:hil} е показан визуално начина на образуване на тази номерация. След завъртанията и долепянията във всяка подрешетка оригиналната подредба се запазва, единственото което се променя е общата подредба. Аналогично могат да се направят криви на Хилберт за по-високи \cite{higher-order} степени. В генералния случай за $d$-измерна крива в хиперкубична решетка с размер на страните $N=2^{dk}$ можем да долепим $2^d$ по-малки такива с размер на страните $N'=2^{d(k-1)}$.

\begin{figure}[H]
\hspace{0.5cm}
\begin{tikzpicture}[scale=0.75]
\draw [-stealth] (-0.5,0.5)--(-0.5,1.5)--(0.5,1.5)--(0.5,0.5);
\draw [step=1.0cm, black] (-1,0) grid (1,2);
\draw [-stealth] (2.5,0.5)--(2.5,1.5)--(3.5,1.5)--(3.5,0.5);    
\draw [step=1.0cm, black] (2,0) grid (4,2);
\draw [-stealth] (-0.5,3.5)--(-0.5,4.5)--(0.5,4.5)--(0.5,3.5);
\draw [step=1.0cm, black] (-1,3) grid (1,5);
\draw [-stealth] (2.5,3.5)--(2.5,4.5)--(3.5,4.5)--(3.5,3.5);
\draw [step=1.0cm, black] (2,3) grid (4,5);
\draw [-stealth,xshift=0cm,yshift=0.5cm] (6.5,0.5)--(7.5,0.5)--(7.5,1.5)--(6.5,1.5);
\draw [step=1.0cm, black,xshift=0cm,yshift=0.5cm] (6,0) grid (8,2);
\draw [-stealth,xshift=-1cm,yshift=0.5cm] (10.5,1.5)--(9.5,1.5)--(9.5,0.5)--(10.5,0.5);
\draw [step=1.0cm, black,xshift=-1cm,yshift=0.5cm] (9,0) grid (11,2);
\draw [-stealth,xshift=0cm,yshift=-0.5cm] (6.5,3.5)--(6.5,4.5)--(7.5,4.5)--(7.5,3.5);
\draw [step=1.0cm, black,xshift=0cm,yshift=-0.5cm] (6,3) grid (8,5);
\draw [-stealth,xshift=-1cm,yshift=-0.5cm] (9.5,3.5)--(9.5,4.5)--(10.5,4.5)--(10.5,3.5);
\draw [step=1.0cm, black,xshift=-1cm,yshift=-0.5cm] (9,3) grid (11,5);
\draw [-stealth,xshift=0cm,yshift=0.5cm] (12.5,0.5)--(13.5,0.5)--(13.5,1.5)--(12.5,1.5)--(12.5,2.5)--(12.5,3.5)--(13.5,3.5)--(13.5,2.5)--(14.5,2.5)--(14.5,3.5)--(15.5,3.5)--(15.5,2.5)--(15.5,1.5)--(14.5,1.5)--(14.5,0.5)--(15.5,0.5);
\draw [step=1.0cm, black,xshift=0cm,yshift=0.5cm] (12,0) grid (16,4);

\draw [-stealth](4.5,2.5)--(5.5,2.5);
\draw [-stealth](10.5,2.5)--(11.5,2.5);
\end{tikzpicture}
\caption{Образуване на крива запълваща $16 \times 16$ решетка от четири $4 \times 4$ решетки.}
\label{constr:hil}
\end{figure}

\begin{figure}[H]
\hspace{0.5cm}
\begin{tikzpicture}[scale=0.75]
\node[align=center] at (-0.5,0.5) {0};
\node[align=center] at (-0.5,1.5) {1};
\node[align=center] at (0.5,1.5) {2};
\node[align=center] at (0.5,0.5) {3};
\draw [step=1.0cm, black] (-1,0) grid (1,2);
\node[align=center] at (2.5,0.5) {0};
\node[align=center] at (2.5,1.5) {1};
\node[align=center] at (3.5,1.5) {2};
\node[align=center] at (3.5,0.5) {3};
\draw [step=1.0cm, black] (2,0) grid (4,2);
\node[align=center] at (-0.5,3.5) {0};
\node[align=center] at (-0.5,4.5) {1};
\node[align=center] at (0.5,4.5) {2};
\node[align=center] at (0.5,3.5) {3};
\draw [step=1.0cm, black] (-1,3) grid (1,5);
\node[align=center] at (2.5,3.5) {0};
\node[align=center] at (2.5,4.5) {1};
\node[align=center] at (3.5,4.5) {2};
\node[align=center] at (3.5,3.5) {3};
\draw [step=1.0cm, black] (2,3) grid (4,5);
\node[align=center] at (6.5,1.0) {0};
\node[align=center] at (7.5,1.0) {1};
\node[align=center] at (7.5,2.0) {2};
\node[align=center] at (6.5,2.0) {3};
\draw [step=1.0cm, black,xshift=0cm,yshift=0.5cm] (6,0) grid (8,2);
\node[align=center] at (9.5,2.0) {0};
\node[align=center] at (8.5,2.0) {1};
\node[align=center] at (8.5,1.0) {2};
\node[align=center] at (9.5,1.0) {3};
\draw [step=1.0cm, black,xshift=-1cm,yshift=0.5cm] (9,0) grid (11,2);
\node[align=center] at (6.5,3.0) {0};
\node[align=center] at (6.5,4.0) {1};
\node[align=center] at (7.5,4.0) {2};
\node[align=center] at (7.5,3.0) {3};
\draw [step=1.0cm, black,xshift=0cm,yshift=-0.5cm] (6,3) grid (8,5);
\node[align=center] at (8.5,3.0) {0};
\node[align=center] at (8.5,4.0) {1};
\node[align=center] at (9.5,4.0) {2};
\node[align=center] at (9.5,3.0) {3};
\draw [step=1.0cm, black,xshift=-1cm,yshift=-0.5cm] (9,3) grid (11,5);
\node[align=center] at (12.5,1.0) {0};
\node[align=center] at (13.5,1.0) {1};
\node[align=center] at (13.5,2.0) {2};
\node[align=center] at (12.5,2.0) {3};
\node[align=center] at (12.5,3.0) {4};
\node[align=center] at (12.5,4.0) {5};
\node[align=center] at (13.5,4.0) {6};
\node[align=center] at (13.5,3.0) {7};
\node[align=center] at (14.5,3.0) {8};
\node[align=center] at (14.5,4.0) {9};
\node[align=center] at (15.5,4.0) {10};
\node[align=center] at (15.5,3.0) {11};
\node[align=center] at (15.5,2.0) {12};
\node[align=center] at (14.5,2.0) {13};
\node[align=center] at (14.5,1.0) {14};
\node[align=center] at (15.5,1.0) {15};
\draw [step=1.0cm, black,xshift=0cm,yshift=0.5cm] (12,0) grid (16,4);
\end{tikzpicture}
\caption{Номерация на пътя на кривата}
\label{numb:hil}
\end{figure}

\subsubsection{Свойства за локалност}

Ще докажем, че дължината на манхатанов хамилтонов път измежду $|Q|$ точки, които са подредени по реда на кривата на Хилберт, в $d$-измерна решетка във формата на хиперкуб с размер на страните $N$ е $O(d*|Q|^{\frac{(d-1)}{d}}*N)$. За улеснение следващото доказателство използва $N=2^k$ и $|Q|=2^{dk'}$, където $d$ е броя измерения, т.е. ако $|Q|$ или $N$ не спазват тези условия, ще ги увеличaваме докато това не се случи. Това няма да промени  сложност на алгоритъма.

\begin{myproof}
Нека разделим решетката на d-измерни хиперкубични подрешетки с размер на страната $2^{k-k'}$.
Първо ще разгледаме разстоянието, което пътя трябва да измине да обиколи всички подрешетки. Броя на подрешетките е $(2^{k'})^d  = 2^{dk'}$. Предвижването между две такива е от порядък $O(d*2^{k-k'})$. Така сложността за минаване през всички е $O(2^{k-k'} * d * 2^{dk'}) = O(d * 2^{k} * (2^{k'})^{d-1}) = O(d *|Q|^{\frac{(d-1)}{d}}*N)$.
Остава да се разгледа единствено допълнителното разстояние, което пътя трябва да премине, за да обиколи всички точки във всяка подрешетка. Поради рекурсивната природа на кривата всички точки от подрешетката ще бъдата последователни в подреждането. Следователно горна граница на това разстояние е максималното разстояние в една подрешетка умножено по броя точки: $O(d*|Q|*2^{k-k'})=O(d *|Q|^{\frac{(d-1)}{d}}*N)$. С това доказваме твърдението за порядъка на общата дължина на пътя. 
\end{myproof}

\section{Изследвания}
\subsection{Черната кутия}
Задачата за отговаряне на въпроси, свързани със сума в интервал, е избрана като подходяща за сравнение. Тъй като обратната операция на събирането е изваждането, можем да изведем лесен псевдокод на черната кутия, който работи със сложност $O(1)$. Чрез избор на проста задача за отговор можем да избегнем случайния елемент. 

\renewcommand{\baselinestretch}{1}
\begin{algorithm}[H]
\caption{Добавяне към черната кутия}
\KwData{$T$ "черната кутия"}
\KwData{$x$ стойност, която трябва да бъде добавена}
\KwResult{$T$ съдържащо информация за променената сума}
$T.sum \gets T.sum + x$
\end{algorithm}
\renewcommand{\baselinestretch}{1.50}

\renewcommand{\baselinestretch}{1}
\begin{algorithm}[H]
\caption{Изваждане от черната кутия}
\KwData{$T$ "черната кутия"}
\KwData{$x$ стойност, която трябва да бъде извадена}
\KwResult{$T$ съдържащо информация за променената сума}
$T.sum \gets T.sum - x$
\end{algorithm}
\renewcommand{\baselinestretch}{1.50}

\subsection{Сравнение с разделянето на ленти}
Поради сходството между двата метода е добре да се направи сравнение между тях. На графики \ref{bench:static:fake} и \ref{bench:dynamic:fake} са разгледани времената за изпълнение на заявки с и без обновления. Вижда се как предложеният метод е с $20\%$ по-добър от разделянето на ленти. 

\begin{figure}[H]
\hspace{1.5cm}
\begin{tikzpicture}
\begin{axis}[
    %title={Време за изпълнение на задача за отговор за интервална сума без обновления\\},
    xlabel={$log_2(N)=log_2(|Q|)=log_2(|U|)$},
    ylabel={Време за изпълнение[ms]},
    xmin=16, xmax=21,
    ymin=0, ymax=12000,
    xtick={14, 15, 16,17,18,19,20, 21},
    ytick={0,2000,4000,6000,8000,10000},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
]
\addplot[
    color=blue]
    coordinates {
    (14, 33)(15, 67)(16, 142)(17, 308)(18, 661)(19, 1693)(20, 4132)(21, 10601)
    };

\addplot[
    color=red]
    coordinates {
    (14, 33)(15, 67)(16, 142)(17, 313)(18, 707)(19, 1447)(20, 3255)(21, 8204)
    };
\legend{Разделяне на ленти, Подреждане чрез Хилберт}
\end{axis}
\end{tikzpicture}
\caption{Измерване без обновления}
\label{bench:static:fake}
\end{figure}

\begin{figure}[H]
\hspace{1.5cm}
\begin{tikzpicture}
\begin{axis}[
    xlabel={$log_2(N)=log_2(|Q|)=log_2(|U|)$},
    ylabel={Време за изпълнение[ms]},
    xmin=16, xmax=19,
    ymin=0, ymax=23000,
    xtick={14, 15, 16,17,18,19},
    ytick={0,5000,10000,15000,20000,23000},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
]
\addplot[
    color=blue]
    coordinates {
    (15, 244)(16, 727)(17, 2186)(18, 6948)(19, 22306)
    };

\addplot[
    color=red]
    coordinates {
    (15, 231)(16, 669)(17, 2036)(18, 6236)(19, 19769)
    };
\legend{Разделяне на ленти, Подреждане чрез Хилберт}
\end{axis}
\end{tikzpicture}
\caption{Измерване с обновления}
\label{bench:dynamic:fake}
\end{figure}

\subsection{Сравнение със сегментно дърво}
В измерванията е добавен алгоритъма на сегментото дърво. Фигура \ref{bench:static} разглежда случая, когато няма обновления, а Фигура \ref{bench:dynamic}, когато има.

\begin{figure}[H]
\hspace{1.5cm}
\begin{tikzpicture}
\begin{axis}[
    %title={Време за изпълнение на задача за отговор за интервална сума без обновления\\},
    xlabel={$log_2(N)=log_2(|Q|)=log_2(|U|)$},
    ylabel={Време за изпълнение[ms]},
    xmin=16, xmax=21,
    ymin=0, ymax=12000,
    xtick={14, 15, 16,17,18,19,20, 21},
    ytick={0,2000,4000,6000,8000,10000},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
]
\addplot[
    color=blue]
    coordinates {
    (14, 33)(15, 67)(16, 142)(17, 308)(18, 661)(19, 1693)(20, 4132)(21, 10601)
    };

\addplot[
    color=red]
    coordinates {
    (14, 33)(15, 67)(16, 142)(17, 313)(18, 707)(19, 1447)(20, 3255)(21, 8204)
    };

\addplot[
    color=green]
    coordinates {
    (14, 28)(15, 53)(16, 105)(17, 215)(18, 449)(19, 954)(20, 1995)(21, 4176)
    };
\legend{Разделяне на ленти, Подреждане чрез Хилберт,Сегментно дърво}
\end{axis}
\end{tikzpicture}
\caption{Измерване без обновления}
\label{bench:static}
\end{figure}

\begin{figure}[H]
\hspace{1.5cm}
\begin{tikzpicture}
\begin{axis}[
    xlabel={$log_2(N)=log_2(|Q|)=log_2(|U|)$},
    ylabel={Време за изпълнение[ms]},
    xmin=16, xmax=19,
    ymin=0, ymax=23000,
    xtick={14, 15, 16,17,18,19},
    ytick={0,5000,10000,15000,20000, 23000},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
]
\addplot[
    color=blue]
    coordinates {
    (15, 244)(16, 727)(17, 2186)(18, 6948)(19, 22306)
    };

\addplot[
    color=red]
    coordinates {
    (15, 231)(16, 669)(17, 2036)(18, 6236)(19, 19769)
    };
\addplot[
    color=green]
    coordinates {
    (15, 58)(16, 114)(17, 233)(18, 500)(19, 1062)
    };
\legend{Разделяне на ленти, Подреждане чрез Хилберт,Сегментно дърво}
\end{axis}
\end{tikzpicture}
\caption{Измерване с обновления}
\label{bench:dynamic}
\end{figure}

Спирайки се на фигура \ref{bench:static} е неочаквано, че сегментното дърво се справя едва 2 пъти по-добре от алгоритмите, служещи си с черна кутия (Разглеждайки сложносностите $O(\frac{|Q|*logN}{d*|Q|^{\frac{(d-1)}{d}}*N}) \approx O(\frac {logN}{d*|Q|^{\frac{1}{2}}}) \approx \frac{21}{2*1000} \approx \frac{1}{100}$ е теоретично-\\предполагаемото отношение). При фигура \ref{bench:dynamic} отново наблюдаваме, че отношението е много по-малко, отколкото е теоретично-предполагаемото. По аналогични разсъждения за триизмерна крива, очакваното отношение е $O(\frac{|Q|*logN}{d*|Q|^{\frac{(d-1)}{d}}*N}) \approx O(\frac {logN}{d*|Q|^{\frac{2}{3}}}) \approx \frac{21}{3*9000} \approx \frac{1}{2000}$, а на практика то е $\frac{1}{20}$.
\par
Нека да разгледаме други статистики като брой кеш-пропуски, които са важни при разглеждането на ефикасността на алгоритмите. На графикa \ref{bench:cache} са показани броят пропуски на L3 кеша за задачата, в която са включени обновления.

\begin{figure}[H]
\hspace{1.5cm}
\begin{tikzpicture}
\begin{axis}[
    xlabel={$log_2(N)=log_2(|Q|)=log_2(|U|)$},
    ylabel={Брой кеш-пропуски},
    xmin=15, xmax=19,
    ymin=0, ymax=1200000,
    xtick={15, 16,17,18,19},
    ytick={0,200000,400000,600000,800000,1000000,1200000},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
]
\addplot[
    color=blue]
    coordinates {
    (15, 872)(16, 4279)(17, 25176)(18, 167077)(19, 1067594)
    };

\addplot[
    color=red]
    coordinates {
    (15, 1097)(16, 3558)(17, 21759)(18, 103548)(19, 669749)
    };
\addplot[
    color=green]
    coordinates {
    (15, 2092)(16, 12679)(17, 35958)(18, 254229)(19, 1158642)
    };
\legend{Разделяне на ленти, Подреждане чрез Хилберт,Сегментно дърво}
\end{axis}
\end{tikzpicture}
\caption{Измерване на броя кеш-пропуски}
\label{bench:cache}
\end{figure}

\par
Тук ясно се вижда причината за неочакваната скорост. Можем чрез асимптотични разсъждения да разгледаме броя кеш-пропуски. При сегментното дърво заради начина на разположение на паметта, процесорът не може да разбере следващото докосване в паметта, заради което почти на всяка итерация се получава такъв пропуск, следователно броят пропуски е от порядък $O(|Q|*logN+|U|*logN)$. Различното при сортирането чрез Хилберт е, че там заради последователността на докосваната памет можем да изчислим порядъка на броя пропуски като $O(\frac{d*|Q|^{\frac{(d-1)}{d}}*N}{B})$, където $B$ е броя на елементите, които се побират в една кеш линия. Комбинирайки тези разсъждения с ниската стойност на $d \le 3$ в случая се получава това несъотвествие между теоритичното време за изпълнение и практическото. Важно е да се отбележи, че този алгоритъм се представя ефективно дори без да "знае" за стойността на $B$. Заради това можем да заключим, че е кеш-безразличен(cache-oblivious\cite{prokop}).
\par
В езици като C++ съществува опция за компилиране на кода, възползвайки се от по-дългите регистри, наречена векторизация. Представена е графика \ref{bench:vect}, на която е сравнено времето за изпълнение на кодовете без и с тази опция. Тук отново заради последователността на паметта се наблюдава по-голямо забързване разделянето на ленти и сортирането чрез Хилберт($\approx 15\%$), отколкото при сегментното дърво($\approx 7\%$) . 

\begin{figure}
\hspace{1.5cm}
\begin{tikzpicture}
\begin{axis}[
    xlabel={$log_2(N)=log_2(|Q|)=log_2(|U|)$},
    ylabel={Време за изпълнение[ms]},
    xmin=16, xmax=19,
    ymin=0, ymax=23000,
    xtick={14, 15, 16,17,18,19},
    ytick={0,5000,10000,15000,23000},
    legend pos=north west,
    ymajorgrids=true,
    grid style=dashed,
]
\addplot[
    color=blue]
    coordinates {
    (15, 244)(16, 727)(17, 2186)(18, 6948)(19, 22306)
    };

\addplot[
    color=red]
    coordinates {
    (15, 231)(16, 669)(17, 2036)(18, 6236)(19, 19769)
    };
\addplot[
    color=green]
    coordinates {
    (15, 58)(16, 114)(17, 233)(18, 500)(19, 1062)
    };
\addplot[
    color=cyan]
    coordinates {
    (15, 195)(16, 582)(17, 1736)(18, 5693)(19, 18349)
    };

\addplot[
    color=yellow]
    coordinates {
    (15, 189)(16, 548)(17, 1677)(18, 5162)(19, 16838)
    };
\addplot[
    color=black]
    coordinates {
    (15, 52)(16, 100)(17, 204)(18, 434)(19, 931)
    };
\legend{Разделяне на ленти, Подреждане чрез Хилберт,Сегментно дърво, Разделяне на ленти(век.), Подреждане чрез Хилберт(век.),Сегментно дърво(век.)}
\end{axis}
\end{tikzpicture}
\caption{Измерване на времето при използвана и неизползвана векторизация }
\label{bench:vect}
\end{figure}

\section{Хилбертообразни криви}
\subsection{Проблемът с оригиналната крива}
Разглеждайки случая, в който размерът на оригиналния масив е малко по-голям от степен на двойката, $N=2^k + \epsilon$, кривата ще бъде конструирана в решетка с размер на страната близък до $N'=2^{k+1}$. Това е възможно място за подобрение - трябва да се конструират криви, чиито страни не са степени на двойките.

\begin{definition}
Хилбертообразна $H(N, d)$ крива ще наричаме път, минаващ през клетките на $d$-измерна хиперкубична решетка със страна $N$, която започва от клетка с координати $(0, \underbrace{0, \cdots, 0}_{d-1})$ и завървша в $(N-1, \underbrace{0, \cdots, 0}_{d-1})$. Начало ще наричаме съответно първата клетка, а край - последната.
\end{definition}

\subsection{Решение на случая d=2}
\label{d:2}
\begin{theorem}
Ако съществуват $H(n, 2)$ и $H(m, 2)$, то можем да конструираме $H(nm, 2)$.
\label{constr}
\end{theorem}
\begin{myproof}
(Съпътстващите фигури разглеждат примера $n=3$, $m=2$.)\\
Ще разделим $nm \times nm$ решетката на непокриващи се $n \times n$ подрешетки като в \ref{proof:cut}. Ще съставим път, който минава по всяка подрешетка последователно, следвайки пътя, образуван от $H(m, 2)$. Остава да определим ориентацията на пътя във всяка подрешетка, която ще бъде обиколена от $H(n, 2)$. За улеснение ще разглеждаме само началото и края на всяка такава. В доказателството обозначаваме горния ляв ъгъл и долния десен ъгъл като нечетни, а горния десен и долния ляв - четни. 
%(на фигурите, които следват всяка клетка ще изобразява $n \times n$ подрешетка и със стрелка от единия неин ъгъл до друг съседен по страна такъв ще се показват връзката начало-край). 
Ще представим конструктивно доказателството, разгледано в няколко стъпки. Конструкцията ще е такава, че ако от една подрешетка трябва да преминем в съседна, то краят на първата такава ще бъде съседен с началото на втората.\\  Стъпки:\\
1) Ще разгледаме ориентацията на първата подрешетка (това е долната лява такава). Ако след нея трябва да преминем вдясно, тя ще бъде ориентирана по начин \ref{first:1}, ако не - по начин \ref{first:2}. Така краят на подрешетката ще бъде съседен на следващата такава. Началото на първата подрешетка се пада в четна клетка, а краят в нечетна.\\
2) Ще ориентираме всички без последната подрешеткa.  Допускаме, че сме обходили първите $k-1$ и края на $(k-1)$-вата е нечетен и съседен на $k$-тата подрешетка в реда на обхождането. Началото на тази $k$-тата $H(n, 2)$ трябва да поставим в ъгъла, съседен на края на предходната подрешетка. Той ще бъде четен. Знаем, че от четно начало можем да ориентираме $H(n, 2)$, така че краят ѝ да е в който и да е от двата нечетни ъгъла, следователно е възможно да нагласим продължаването в следващата подрешетка в обхождането.  \\
3) В края на конструкцията е нагласянето на последната подрешетка. От конструкцията на останалите подрешетки можем да заключим, че началото й ще бъде четно. С това е ясно, че пътят в последната подрешетка може да се ориентира, така че краят на цялата $H(nm, 2)$ да е в долния десен ъгъл на решетката.
\end{myproof}

\begin{figure}[H]
    \centering
    \subfloat[\centering]{
        \begin{tikzpicture}[scale=0.75]
            \draw [step=0.8333333333333334cm, black] (0,0) grid (5,5);
            \draw [line width=1.5] (2.5, 0)--(2.5,5);
            \draw [line width=1.5] (0, 2.5)--(5, 2.5);
        \end{tikzpicture}
        \label{proof:cut}
    }
    \hspace{0.5cm}
    \subfloat[\centering]{
        \begin{tikzpicture}[scale=0.75]
            \draw [step=0.8333333333333334cm, black] (0,0) grid (5,5);
            \draw [line width=1.5] (2.5, 0)--(2.5,5);
            \draw [line width=1.5] (0, 2.5)--(5, 2.5);
            
            \draw [-stealth, line width=1.5, dotted,color=red]
            (0.4166666666666667,0.4166666666666667)--(0.4166666666666667,2.0833333333333335);
            \draw [-stealth, line width=1.5, dotted,color=red](0.4166666666666667,2.9166666666666665)--(2.0833333333333335,2.9166666666666665);
            \draw [-stealth, line width=1.5, dotted,color=red](2.9166666666666665,2.9166666666666665)--(4.583333333333334,2.9166666666666665);
            \draw [-stealth, line width=1.5, dotted,color=red](4.583333333333334,2.0833333333333335)--(4.583333333333334,0.4166666666666667);
        \end{tikzpicture}
        \label{proof:orientation}
    }
    \hspace{0.5cm}
    \subfloat[\centering]{
        \begin{tikzpicture}[scale=0.75]
            \draw [-stealth] (0.4166666666666667,0.4166666666666667)--(1.25,0.4166666666666667)--(2.0833333333333335,0.4166666666666667)--(2.0833333333333335,1.25)--(2.0833333333333335,2.0833333333333335)--(1.25,2.0833333333333335)--(1.25,1.25)--(0.4166666666666667,1.25)--(0.4166666666666667,2.0833333333333335);
            \draw [-stealth] (0.4166666666666667,2.9166666666666665)--(0.4166666666666667,3.75)--(0.4166666666666667,4.583333333333334)--(1.25,4.583333333333334)--(2.0833333333333335,4.583333333333334)--(2.0833333333333335,3.75)--(1.25,3.75)--(1.25,2.9166666666666665)--(2.0833333333333335,2.9166666666666665);
            \draw [-stealth] (2.9166666666666665,2.9166666666666665)--(2.9166666666666665,3.75)--(2.9166666666666665,4.583333333333334)--(3.75,4.583333333333334)--(4.583333333333334,4.583333333333334)--(4.583333333333334,3.75)--(3.75,3.75)--(3.75,2.9166666666666665)--(4.583333333333334,2.9166666666666665);
            \draw [-stealth] (4.583333333333334,2.0833333333333335)--(3.75,2.0833333333333335)--(2.9166666666666665,2.0833333333333335)--(2.9166666666666665,1.25)--(2.9166666666666665,0.4166666666666667)--(3.75,0.4166666666666667)--(3.75,1.25)--(4.583333333333334,1.25)--(4.583333333333334,0.4166666666666667);
            \draw [step=0.8333333333333334cm, black] (0,0) grid (5,5);
            \draw [line width=1.5] (2.5, 0)--(2.5,5);
            \draw [line width=1.5] (0, 2.5)--(5, 2.5);
        \end{tikzpicture}
        \label{proof:curves}
    }
    \caption{Конструктивният процес на образуване на $H(6, 2)$}
\end{figure}

\begin{figure}[H]
    \centering
    \subfloat[\centering]{
        \begin{tikzpicture}[scale=0.75]
            \draw [step=1.6666666666666667cm, black,xshift=7.5cm,yshift=0cm] (0,0) grid (5,5);
            \draw [-stealth,xshift=7.5cm,yshift=0cm] (0.8333333333333334,0.8333333333333334)--(0.8333333333333334,2.5)--(0.8333333333333334,4.166666666666667)--(2.5,4.166666666666667)--(4.166666666666667,4.166666666666667)--(4.166666666666667,2.5)--(2.5,2.5)--(2.5,0.8333333333333334)--(4.166666666666667,0.8333333333333334);
        \end{tikzpicture}
        \label{first:1}
    }
    \hspace{0.5cm}
    \subfloat[\centering]{
        \begin{tikzpicture}[scale=0.75]
            \draw [step=1.6666666666666667cm, black,xshift=7.5cm,yshift=0cm] (0,0) grid (5,5);
            \draw [-stealth,xshift=7.5cm,yshift=0cm] (0.8333333333333334,0.8333333333333334)--(2.5,0.8333333333333334)--(4.166666666666667,0.8333333333333334)--(4.166666666666667,2.5)--(4.166666666666667,4.166666666666667)--(2.5, 4.166666666666667)--(2.5,2.5)--(0.8333333333333334,2.5)--(0.8333333333333334,4.166666666666667);
        
        \end{tikzpicture}
        \label{first:2}
    }
    \caption{Случаи за първата подрешетка}
\end{figure}

\subsection{Пълно изчерпване за откриване на някои H(n, 2)}
Предложен е алгоритъм, който е установен като експериментално ефективен за намиране на "добри" $H(n, 2)$. Ще изчислим фитнеса на една хилбертообразна крива като разгледаме набор от множества, съставени от случайни точки. След това всяко такова множество ще бъде подредено в реда, по който кривата обхожда точките в него, и ще намерим дължината на пътя, минаващ през всички такива, образуван чрез това обхождане. Псевдокод \ref{find:fitness} отговаря на описанието на тази фитнес функция.


\RestyleAlgo{ruled}
\SetKwComment{Comment}{/* }{ */}
\begin{algorithm}
\caption{Определяне на фитнес на решение}\label{find:fitness}
\KwData{$curve$ $H(n, 2)$, която трябва да се оцени}
\KwResult{$fitness$ - Число, определящо фитнес на кривата, колкото по-малко е то, толкова по-добре се справя кривата на практика}
$fitness \gets 0$\;
\For{constant number of iterations} {
    \tcp*[h]{points e инициализирана със случаен брой координати на клетки в решетка $N \times N$}\\
    $points \gets randompoints(n, n)$\; 
    \tcp*[h]{Сортира точките в реда на обхождане от curve}\\
    $sort(points, curve)$\; 
    \tcp*[h]{Добавя дължината на пътя образуван от точките}\\
    $fitness \gets fitness + length(points)$
}
\end{algorithm}
\renewcommand{\baselinestretch}{1.50}

\begin{figure}[H]
\hspace{0.2cm}
\begin{tikzpicture}[scale=0.90]
\begin{scope}[xshift = 2cm]
\draw [-stealth,xshift=2cm,yshift=0cm] (1.25,1.25)--(1.25,3.75)--(3.75,3.75)--(3.75,1.25);
\draw [step=2.5cm, black,xshift=2cm,yshift=0cm] (0,0) grid (5,5);
\draw [-stealth,xshift=7.5cm,yshift=0cm] (0.8333333333333334,0.8333333333333334)--(0.8333333333333334,2.5)--(0.8333333333333334,4.166666666666667)--(2.5,4.166666666666667)--(4.166666666666667,4.166666666666667)--(4.166666666666667,2.5)--(2.5,2.5)--(2.5,0.8333333333333334)--(4.166666666666667,0.8333333333333334);
\draw [step=1.6666666666666667cm, black,xshift=7.5cm,yshift=0cm] (0,0) grid (5,5);
\draw [-stealth,xshift=13cm,yshift=0cm] (0.625,0.625)--(1.875,0.625)--(1.875,1.875)--(0.625,1.875)--(0.625,3.125)--(0.625,4.375)--(1.875,4.375)--(1.875,3.125)--(3.125,3.125)--(3.125,4.375)--(4.375,4.375)--(4.375,3.125)--(4.375,1.875)--(3.125,1.875)--(3.125,0.625)--(4.375,0.625);
\draw [step=1.25cm, black,xshift=13cm,yshift=0cm] (0,0) grid (5,5);
\draw [-stealth,xshift=2cm,yshift=-5.5cm] (0.5,0.5)--(1.5,0.5)--(1.5,1.5)--(0.5,1.5)--(0.5,2.5)--(1.5,2.5)--(1.5,3.5)--(0.5,3.5)--(0.5,4.5)--(1.5,4.5)--(2.5,4.5)--(2.5,3.5)--(2.5,2.5)--(3.5,2.5)--(3.5,3.5)--(3.5,4.5)--(4.5,4.5)--(4.5,3.5)--(4.5,2.5)--(4.5,1.5)--(3.5,1.5)--(2.5,1.5)--(2.5,0.5)--(3.5,0.5)--(4.5,0.5);
\draw [step=1.0cm, black,xshift=2cm,yshift=-5.5cm] (0,0) grid (5,5);
\draw [-stealth,xshift=7.5cm,yshift=-5.5cm] (0.4166666666666667,0.4166666666666667)--(0.4166666666666667,1.25)--(1.25,1.25)--(1.25,0.4166666666666667)--(2.0833333333333335,0.4166666666666667)--(2.0833333333333335,1.25)--(2.0833333333333335,2.0833333333333335)--(1.25,2.0833333333333335)--(0.4166666666666667,2.0833333333333335)--(0.4166666666666667,2.9166666666666665)--(1.25,2.9166666666666665)--(1.25,3.75)--(0.4166666666666667,3.75)--(0.4166666666666667,4.583333333333334)--(1.25,4.583333333333334)--(2.0833333333333335,4.583333333333334)--(2.0833333333333335,3.75)--(2.0833333333333335,2.9166666666666665)--(2.9166666666666665,2.9166666666666665)--(2.9166666666666665,3.75)--(2.9166666666666665,4.583333333333334)--(3.75,4.583333333333334)--(4.583333333333334,4.583333333333334)--(4.583333333333334,3.75)--(3.75,3.75)--(3.75,2.9166666666666665)--(4.583333333333334,2.9166666666666665)--(4.583333333333334,2.0833333333333335)--(3.75,2.0833333333333335)--(2.9166666666666665,2.0833333333333335)--(2.9166666666666665,1.25)--(2.9166666666666665,0.4166666666666667)--(3.75,0.4166666666666667)--(3.75,1.25)--(4.583333333333334,1.25)--(4.583333333333334,0.4166666666666667);
\draw [step=0.8333333333333334cm, black,xshift=7.5cm,yshift=-5.5cm] (0,0) grid (5,5);
\draw [-stealth,xshift=13cm,yshift=-5.5cm] (0.35714285714285715,0.35714285714285715)--(1.0714285714285714,0.35714285714285715)--(1.7857142857142858,0.35714285714285715)--(1.7857142857142858,1.0714285714285714)--(1.0714285714285714,1.0714285714285714)--(0.35714285714285715,1.0714285714285714)--(0.35714285714285715,1.7857142857142858)--(1.0714285714285714,1.7857142857142858)--(1.7857142857142858,1.7857142857142858)--(1.7857142857142858,2.5)--(1.0714285714285714,2.5)--(0.35714285714285715,2.5)--(0.35714285714285715,3.2142857142857144)--(0.35714285714285715,3.928571428571429)--(0.35714285714285715,4.642857142857142)--(1.0714285714285714,4.642857142857142)--(1.0714285714285714,3.928571428571429)--(1.0714285714285714,3.2142857142857144)--(1.7857142857142858,3.2142857142857144)--(1.7857142857142858,3.928571428571429)--(1.7857142857142858,4.642857142857142)--(2.5,4.642857142857142)--(2.5,3.928571428571429)--(2.5,3.2142857142857144)--(3.2142857142857144,3.2142857142857144)--(3.2142857142857144,3.928571428571429)--(3.2142857142857144,4.642857142857142)--(3.928571428571429,4.642857142857142)--(4.642857142857142,4.642857142857142)--(4.642857142857142,3.928571428571429)--(3.928571428571429,3.928571428571429)--(3.928571428571429,3.2142857142857144)--(4.642857142857142,3.2142857142857144)--(4.642857142857142,2.5)--(3.928571428571429,2.5)--(3.2142857142857144,2.5)--(2.5,2.5)--(2.5,1.7857142857142858)--(3.2142857142857144,1.7857142857142858)--(3.928571428571429,1.7857142857142858)--(4.642857142857142,1.7857142857142858)--(4.642857142857142,1.0714285714285714)--(3.928571428571429,1.0714285714285714)--(3.2142857142857144,1.0714285714285714)--(2.5,1.0714285714285714)--(2.5,0.35714285714285715)--(3.2142857142857144,0.35714285714285715)--(3.928571428571429,0.35714285714285715)--(4.642857142857142,0.35714285714285715);
\draw [step=0.7142857142857143cm, black,xshift=13cm,yshift=-5.5cm] (0,0) grid (5,5);
\draw [-stealth,xshift=7.5cm,yshift=-11cm] (0.3125,0.3125)--(0.3125,0.9375)--(0.9375,0.9375)--(0.9375,0.3125)--(1.5625,0.3125)--(2.1875,0.3125)--(2.1875,0.9375)--(1.5625,0.9375)--(1.5625,1.5625)--(2.1875,1.5625)--(2.1875,2.1875)--(1.5625,2.1875)--(0.9375,2.1875)--(0.9375,1.5625)--(0.3125,1.5625)--(0.3125,2.1875)--(0.3125,2.8125)--(0.9375,2.8125)--(0.9375,3.4375)--(0.3125,3.4375)--(0.3125,4.0625)--(0.3125,4.6875)--(0.9375,4.6875)--(0.9375,4.0625)--(1.5625,4.0625)--(1.5625,4.6875)--(2.1875,4.6875)--(2.1875,4.0625)--(2.1875,3.4375)--(1.5625,3.4375)--(1.5625,2.8125)--(2.1875,2.8125)--(2.8125,2.8125)--(3.4375,2.8125)--(3.4375,3.4375)--(2.8125,3.4375)--(2.8125,4.0625)--(2.8125,4.6875)--(3.4375,4.6875)--(3.4375,4.0625)--(4.0625,4.0625)--(4.0625,4.6875)--(4.6875,4.6875)--(4.6875,4.0625)--(4.6875,3.4375)--(4.0625,3.4375)--(4.0625,2.8125)--(4.6875,2.8125)--(4.6875,2.1875)--(4.6875,1.5625)--(4.0625,1.5625)--(4.0625,2.1875)--(3.4375,2.1875)--(2.8125,2.1875)--(2.8125,1.5625)--(3.4375,1.5625)--(3.4375,0.9375)--(2.8125,0.9375)--(2.8125,0.3125)--(3.4375,0.3125)--(4.0625,0.3125)--(4.0625,0.9375)--(4.6875,0.9375)--(4.6875,0.3125);
\draw [step=0.625cm, black,xshift=7.5cm,yshift=-11cm] (0,0) grid (5,5);
\end{scope}
\end{tikzpicture}
\caption{$H(N, 2), N \le 8$}
\label{hilbertian}
\end{figure}

За намирането на самите $H(n, 2)$ е използвано пълно dfs-изчерпване. Използвани са някои евристики, за да се забърза изпълнението на програмата. До тях е стигнато, разглеждайки естеството на $H(n, d)$, в частност ако кривата мине през клетката, която трябва да е последна преди обхождането на останалите, то тя няма как да се върне в нея в края. Друго невалидно продължение се случва, когато кривата не може да стигне до края без да мине през себе си. На фигура \ref{hilbertian} са представени намерените криви за $3, 4, 5, 6, 7, 8$. Важно е да се отбележи, че кривите за $2, 4$ и $8$ са точно кривите на Хилберт. Конструкцията на $H(6, 2)$ е подобна на такава получена чрез теоремата от \ref{d:2}, по-големи решетки могат да се получат прилагайки я неколкократно.

\section{Други задачи, решими с метода}
Можем да разгледаме задачата, в която въпросът се отнася единствено до елементите в интервала, чиято стойност е между $x$ и $y$ ($x$ и $y$ са специфични за всяка заявка). Тук черна кутия със сложност $O(1)$ може да бъде съставена и ще разгледаме минимален хамилтонов път между точките $(l, r, u, x, y)$. Методът, описан в статията постига сложност $O(|Q|^{\frac{4}{5}}*max(N, |U|, A))$, където $A$ е максималната стойност на $x$ и $y$. Важно е да се отбележи, че чрез структури от данни като рядко сегментно дърво(sparse segment tree), можем да достигнем до решение със сложност $O(|Q|*log^{3}N + |U|*log^{3}N)$, но отново ще се наблюдава голяма константа при това решение. Вижда се приложимостта върху други задачи, в които съществува $O((|Q|+|U|)*log^{k}N)$, но с по-ниска константа.
\par
Методът е приложим на много различни типове въпроси, за които не съществува полилогаритмично решение. Примери за такива са намиране на mex (функция важна в безпристрастните (impartial) игри), брой инверсии в интервала и други. Това, което го прави добър, е ниската константа, която може да се осигури заради последователността на докосваните елементи в паметта.    

\section{По-нататъшно развитие}
\linespread{1}
\subsection{Разширяване на метода}
Тъй като в тази статия е разгледана черна кутия с равна сложност на добавяне и изваждане, то логично продължение е разглеждане на такава със сложност $O(A)$ за добавяне на елемент, $O(R)$ изваждане на елемент и $O(M)$ за модифициране на такъв вътре в нея (този тип операции не е разглеждан в настоящата статия, но би представлявал интерес за бъдещото развитие). 

\subsection{Различни криви}
Някои структури от данни поддържат по-бързо едновременно добавяне на елементи или изваждане на такива, т.е. може да се разгледат различни криви, възползващи се от този факт.  

\subsection{Използване на по-добри апроксимиращи алгоритми в задачата за минимален хамилтонов път}
Тъй като методът се опира на задачата за минимален манхатанов хамилтонов път, то като продължение може да се разгледа използването на други апроксимиращи алгоритми. Пример за такъв е 
$2$-апроксимиращият, който използва минимално покриващо дърво в графа. Минимално покриващо дърво на граф, образуван измежду точки в двуизмерното пространство, има познато полиномиално решение, следователно е добра посока за разглеждане и сравнение. 

\subsection{Използване на машинно обучение за откриване на \\Хилбертообразни криви}
Тъй като алгоритъмът за откриване на Хилбертообразни криви в двуизмерна решетка, предложен в тази статия, използва $20$ минути за създаване на $H(8, 2)$, то следва, че методът не е приложим за по-големи решетки и измерения. Възможни посоки за откриване на $H(N, d)$ са пълно изчерпване с подреждане на съседните стейтове чрез евристика или невронна мрежа. Друг подход за задачата е използването на $2$-opt или други генетични алгоритми, възползвайки се от функцията, определяща фитнеса на решението.  

\section{Заключение}
В настоящата статия е разгледан начин, по който могат да бъдат решавани въпроси, свързани със заявки в масив от данни. Изложеният метод е около $20\%$ по-бърз от най-добрия генерален познат такъв. Разгледано е също и представянето му срещу сегментното дърво и са открити причините, заради които порядъкът на отношенията е по-малък от очаквания. Въведени са Хилбертообразни криви, които помагат за справянето със случая $N \ne 2^k$ за $k \in \mathbb{Z}_+$. Представени са и разширения на метода за задачи, имащи познати решения със сложност $O(|Q|*log^kN)$, които могат да се решат чрез криви на Хилберт от по-високи измерения. Разгледани са начини за изчисляване на $H(N, 2)$ за $N$.

\section{Забележки по реализацията на проекта}
    Статията е писана в онлайн средата за разработка на latex \href{https://www.overleaf.com}{Overleaf}. Кодът, използван за сравнения на алгоритмите, е писан на C++ и компилиран с g++. За измерването на характеристики на изпълнението на методите е използвана програмата \href{https://man7.org/linux/man-pages/man1/perf-stat.1.html}{perf-stat}. Всеки метод бива пуснат няколко (10) пъти за всички различни стойности на параметрите и е взето средното аритметично от изпълненията. Написани са и набор от помощни програми като тази, генерираща latex код за изображенията на кривите, и такава, която намира Хилбертообразни криви. Всеки код, описан в статията, е авторски и е публикуван в \href{https://github.com/neNasko1/query-ordering}{github} страницата на проекта. Машината, на която са извършени всички измервания, е с процесор Intel(R) Core(TM) i7-6500U CPU @ 2.50Ghz, архитектурата му е x86\_64, размерите на кешовете му са съответно L1i-64KiB, L1d-64KiB, L2-512KiB и L3-4MiB. 

\section{Благодарности}
Благодаря на научния си ръководител Радослав Димитров, както за помощта с избирането на тема, така и заради факта, че винаги беше готов да помогне и да поднесе начин как проектът да бъде подобрен, на Иван Тончев за вдъхновението да се занимавам с компютърните науки и на Цветелина Илиева за пробния прочит. 

\clearpage

\printbibliography

\end{document}
